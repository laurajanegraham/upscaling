---
title: "Appendix I: simulated landscapes"
output: pdf_document
header-includes:
    - \usepackage{booktabs}
---

```{r, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      fig.path = 'figures/',
                      dpi = 300,
                      dev = c('pdf', 'tiff', 'png'),
                      fig.width = 6.496065) # width of full page figure for Ecology Letters
```

# Required packages

In the first step, we load all of the required packages. Note that grainchanger (the package developed for this paper) can be installed using:

`devtools::install_github("laurajanegraham/grainchanger")`

```{r setup}
# load required libraries
library(captioner)
library(knitr)
library(raster)
library(grainchanger)
library(broom)
library(plyr)
library(landscapetools)
library(NLMR)
library(R.utils)
library(tidyverse)
library(cowplot)

# set up plotting options
theme_set(theme_bw(base_size = 7) + theme(strip.background = element_blank(), 
                             panel.grid.major = element_blank(),
                             panel.grid.minor = element_blank()))

# required for captioning and numbering tables and figures
tabs <- captioner(prefix = "Table AI.")
figs <- captioner(prefix = "Figure AI.")
```

# Methods

## Moving window approach

```{r F1_methods_plot, fig.width = 4.33071, fig.height = 2.88714}
ls <- nlm_random(10, 10) %>% as.data.frame(xy = TRUE)
w1 <- data.frame(x = rep(c(0.5, 1.5, 2.5), times = 3), 
                 y = rep(c(7.5, 8.5, 9.5), each = 3))
w2 <- mutate(w1, x = x+1)
w3 <- mutate(w2, x = x+1)

w1_plot <- ggplot() + 
  geom_raster(data = ls, aes(x = x, y = y, fill = layer)) + 
  geom_raster(data = w1, aes(x = x, y = y), fill = "grey", alpha = 0.7) + 
  annotate("text", x = 1.5, y = 8.5, 
           label = "italic(f(x))", parse = TRUE, size = 2.5) +
  annotate("text", x = 0, y = 11.2, hjust = 0, 
           label = "Predictor grain", size = 2.5) +
  annotate("text", x = 0, y = 12.6, hjust = 0, 
           label = "Scale of effect", size = 2.5) +
  annotate("text", x = 0, y = 14, hjust = 0, 
           label = "Response grain", size = 2.5) +
  geom_segment(aes(x=0, xend=1, y=10.5, yend=10.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both")) +
  geom_segment(aes(x=0, xend=3, y=11.9, yend=11.9), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both")) + 
  geom_segment(aes(x=0, xend=10, y=13.3, yend=13.3), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both")) + 
  scale_fill_viridis_c() + 
  coord_equal() + 
  theme(axis.line = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank(),
        axis.title = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none")

w2_plot <- ggplot() + 
  geom_raster(data = ls, aes(x = x, y = y, fill = layer)) + 
  geom_raster(data = w2, aes(x = x, y = y), fill = "grey", alpha = 0.7) + 
  annotate("text", x = 2.5, y = 8.5, 
           label = "italic(f(x))", parse = TRUE, size = 2.5) +
  annotate("text", x = 0, y = 11.2, hjust = 0, 
           label = "Predictor grain", size = 2.5, colour = "white") +
  annotate("text", x = 0, y = 12.6, hjust = 0, 
           label = "Scale of effect", size = 2.5, colour = "white") +
  annotate("text", x = 0, y = 14, hjust = 0, 
           label = "Response grain", size = 2.5, colour = "white") +
  geom_segment(aes(x=0, xend=1, y=10.5, yend=10.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both"), 
               colour = "white") +
  geom_segment(aes(x=0, xend=3, y=11.9, yend=11.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both"), 
               colour = "white") + 
  geom_segment(aes(x=0, xend=10, y=13.3, yend=12.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both"), 
               colour = "white") + 
  scale_fill_viridis_c() + 
  coord_equal() + 
  theme(axis.line = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank(),
        axis.title = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none")

w3_plot <- ggplot() + 
  geom_raster(data = ls, aes(x = x, y = y, fill = layer)) + 
  geom_raster(data = w3, aes(x = x, y = y), fill = "grey", alpha = 0.7) + 
  annotate("text", x = 3.5, y = 8.5, 
           label = "italic(f(x))", 
           parse = TRUE, 
           size = 2.5) +
  annotate("text", x = 0, y = 11.2, hjust = 0, 
           label = "Predictor grain", size = 2.5, colour = "white") +
  annotate("text", x = 0, y = 12.6, hjust = 0, 
           label = "Scale of effect", size = 2.5, colour = "white") +
  annotate("text", x = 0, y = 14, hjust = 0, 
           label = "Response grain", size = 2.5, colour = "white") +
  geom_segment(aes(x=0, xend=1, y=10.5, yend=10.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both"), 
               colour = "white") +
  geom_segment(aes(x=0, xend=3, y=11.9, yend=11.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both"), 
               colour = "white") + 
  geom_segment(aes(x=0, xend=10, y=13.3, yend=12.5), size = 0.5,
               arrow = arrow(length = unit(0.1, "cm"), ends = "both"), 
               colour = "white") + 
  scale_fill_viridis_c() + 
  coord_equal() + 
  theme(axis.line = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank(),
        axis.title = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none")

plot_grid(w1_plot, w2_plot, w3_plot, nrow = 1, axis = "b")
```

`r figs("methods_fig", "Graphical representation of the moving window method. When the moving window is defined, three aspects of scale need to be considered. Predictor grain is the characteristic spatial scale of the predictor variable, i.e. the resolution of the environmental data; scale of effect determines the appropriate scale of the relationship between predictor and response, for example an ecological neighbourhood; response grain is the grain of the unit into which you are predicting, i.e. the resolution of the response variable.")`  

There are three steps involved in our data-aggregation approach: 1) define the appropriate scales for the ecological process; 2) define the appropriate measure of environmental heterogeneity and calculate using a moving window; 3) calculate the mean of the moving window-based measure at the grain of the response (`r figs("methods_fig", display = "cite")`). 

## Simulation One: continuous variables

This simulation shows the use of the moving window based spatial structure measure for continuous variables which have finer scale variation than the resolution of analysis. This could be, for example, topographic or microclimate variation. 

### Simulated landscapes

We simulated landscapes using the fractal Brownian motion method (`nlm_fbm`) from the `NLMR` package [@Sciaini2018]. We simulated landscapes with three levels of spatial autocorrelation, and 100 replicates for each of these. The spatial autocorrelation of the landscape is controlled by the `fract_dim` parameter where a value close to zero is a rough landscape (random), and a value of one is a smooth landscape (spatially autocorrelated). We generated landscapes of 65 x 65 cells using fractal dimension = 0.1, 0.5, 1.

```{r sim_ls, cache = TRUE}
nrows <- ncols <- 65
fract_dim <- c(0.1, 0.5, 1)
radius <- c(1, 10, 20)
reps <- 1:100

# set up a table with all combinations of parameters
params <- expand.grid(ncol = ncols, nrow = nrows, fract_dim = fract_dim, reps = reps)

# simulate 65 x 65 landscapes with variable roughness
sim_ls <- apply(params, 1, function(x) {
  ls <- nlm_fbm(ncol = x['ncol'], 
          nrow = x['nrow'], 
          fract_dim = as.numeric(x['fract_dim']), 
          rescale = TRUE)
  ls_df <- raster::as.data.frame(ls, xy = TRUE) %>% 
    cbind(x %>% as.data.frame %>% t, row.names = NULL)
  return(list(params = x, ls = ls, ls_df = ls_df))
})
```

### Calculate MW environmental heterogeneity

We used the `winmove` function from the [`grainchanger`](https://github.com/laurajanegraham/grainchanger) package to gain a moving-window based range and variance of the continuous variable at 3 different window radii: 1 = small; 7 = medium; 17 = large. The window sizes represent the appropriate scale of effect of the continuous variable on the response. For the MW variance calculation, we scaled the landscapes to have a mean of 0 and variance of 1. For the MW range calculation we min-max scaled the landscapes to take values between 0 and 1. In both cases, the metric when calculated at the landscape scale without the moving window is 1. The `create_torus()` function (also in the `grainchanger` package) allows us to buffer a given landscape by a given radius, creating the effect of a torus, and thus avoiding issues of edge effects. 

```{r contsim_winmove, cache = TRUE}
cont_res <- ldply(sim_ls, function(x) {
  ls <- x$ls 
  ldply(radius, function(r) {
    ls_pad <- create_torus(ls, r)
    # scale to make variance identical across landscapes
    mw_var <- winmove(raster::scale(ls_pad), radius = r, type = "rectangle", fn = "var")
    mw_var <- raster::trim(mw_var) 
    mw_range <- winmove(ls_pad, radius = r, type = "rectangle", fn = "var_range")
    mw_range <- raster::trim(mw_range) 
    out <- data.frame(t(x$params), 
                      radius = r, 
                      val = c(mw_var %>% values %>% mean,
                              mw_range %>% values %>% mean),
                      measure = c("MW variance", "MW range"))
  })
}) %>% 
  mutate(radius = factor(radius, 
                         labels = c("Small: 1", 
                                    "Medium: 10", 
                                    "Large: 20")), 
         fract_dim = factor(paste0("Fractal dimension = ", fract_dim)))
```

## Simulation Two: categorical variables

This simulation will show the use of the moving window-based spatial structure measure for categorical variables which have finer scale variation than the resolution of analysis. This is appropriate for more classical landscape ecology questions about habitat structure. On these landscapes we calculated Shannon evenness (MW Shannon) and standardised patch richness (MW richness). 

### Simulated landscapes

We will use the simulated landscapes from the previous example, and use the `util_classify` function to classify into equal proportions of five habitat types. When calculating the landscape scale metrics (MW Shannon and MW richness) without a moving window, the value in both cases is 1. 

### Calculate MW environmental heterogeneity

We used the `winmove` function from the [`grainchanger`](https://github.com/laurajanegraham/grainchanger) package to gain moving-window based environmental heterogeneity measures (MW Shannon and MW richness) of the categorical variable at 3 different window radius sizes: 1 = small; 7 = medium; 17 = large. The window sizes represent the appropriate scale of effect of the categorical variable on the response. The `create_torus()` function (also in the `grainchanger` package) allows us to buffer a given landscape by a given radius, creating the effect of a torus, and thus avoiding issues of edge effects. 

```{r catsim_winmove, cache = TRUE}
cat_res <- ldply(sim_ls, function(x) {
  ls <- util_classify(x$ls, weighting = rep(1/5, 5))
  ldply(radius, function(r) {
    ls_pad <- create_torus(ls, r)
    # calculate shannon evenness
    mw_shei <- winmove(ls_pad, 
                       radius = r, 
                       type = "rectangle", 
                       fn = "diversity", 
                       lc_class = 0:4)
    mw_shei <- raster::trim(mw_shei) 
    # calculate patch richness index (pr / # landcovers)
    mw_pr <- winmove(ls_pad, 
                     radius = r, 
                     type = "rectangle", 
                     fn = "diversity",
                     index = "pr",
                     lc_class = 0:4)
    mw_pr <- raster::trim(mw_pr/5) # divide by number of landcovers to get value from 0:1
    out <- data.frame(t(x$params), 
                      radius = r, 
                      val = c(mw_shei %>% values %>% mean,
                              mw_pr %>% values %>% mean),
                      measure = c("MW Shannon", "MW richness"))
  })
}) %>% 
  mutate(radius = factor(radius, 
                         labels = c("Small: 1", "Medium: 10", "Large: 20")), 
         fract_dim = factor(paste0("Fractal dimension = ", fract_dim)))
```


# Results

## Plots

```{r F2_sim_figure}
# combine all runs into one dataframe and only take the first replicate of each
# combination for plotting
cont_ls_df <- ldply(sim_ls, function(x) x$ls_df) %>% 
  filter(reps == 1) %>% 
  mutate(ls_type = "Continuous") 


cat_ls_df <- ldply(sim_ls, function(x) {
  ls <- util_classify(x$ls, weighting = rep(1/5, 5))
  ls_df <- raster::as.data.frame(ls, xy = TRUE)
  return(data.frame(t(x$params), ls_df))
}) %>% 
  filter(reps == 1) %>% 
  mutate(ls_type = "Categorical")


cont_ls_plot <- ggplot(cont_ls_df, aes(x = x, y = y, fill = layer)) + 
  geom_raster() + 
  coord_equal() + 
  scale_fill_viridis_c() + 
  theme(axis.text = element_blank(), axis.title = element_blank(), 
        axis.line = element_blank(), axis.ticks = element_blank()) + 
  facet_grid(fract_dim~ls_type) + 
  theme(axis.text = element_blank(), 
        axis.title = element_blank(), 
        axis.line = element_blank(), 
        axis.ticks = element_blank(),
        strip.background = element_blank(), 
        strip.text.y = element_blank(),
        legend.position = "none",
        panel.border = element_blank())

cat_ls_plot <- ggplot(cat_ls_df, aes(x = x, y = y, fill = layer)) + 
  geom_raster() + 
  coord_equal() + 
  scale_fill_viridis_c() + 
  facet_grid(fract_dim~ls_type) + 
  theme(axis.text = element_blank(), 
        axis.title = element_blank(), 
        axis.line = element_blank(), 
        axis.ticks = element_blank(),
        strip.background = element_blank(), 
        strip.text.y = element_blank(),
        legend.position = "none",
        panel.border = element_blank())

res_df <- bind_rows(cont_res, cat_res) %>% 
  mutate(measure = factor(measure, 
                          levels = c("MW range", 
                                     "MW variance", 
                                     "MW richness", 
                                     "MW Shannon")))

res_plot <- ggplot(res_df, aes(x = radius, y = val, fill = measure)) + 
  geom_boxplot(lwd = 0.1, outlier.size = 0.5) + coord_flip() + 
  scale_fill_grey("") + 
  facet_wrap(~fract_dim, ncol = 1) +
  xlab("Moving window radius") + ylab("") 

plot_grid(cont_ls_plot, cat_ls_plot, res_plot, 
          align = 'h', 
          rel_widths = c(1,1,3),
          nrow = 1,
          labels = c("a)", "", "b)"),
          label_size = 7)
```

`r figs("res_plot", "Example landscapes of a continuous and categorical variable for each level of spatial autocorrelation (a). Results of the moving window calculations for simulated landscapes of three levels of spatial autocorrelation (b). MW variance was calculated on a continuous environmental variable with mean = 0 and variance = 1. MW range was calculated on a continuous landscape with values in [0, 1]. MW Shannon and MW richness were calculated on a categorical landscape with five categories of equal proportions. All measures were calculated within moving windows were at three scales-of-effect. Note that when calculated without a moving window, the landscape scale value is 1 in all cases.")`

## Analysis of variance

We used a two-way analysis of variance in order to understand the effect of spatial structure in the landscape and the size of the moving window on the output measure. We focus on the effect size rather than the statistical significance due to the inflated sample size in simulated data. 

```{r aov}
res_df %>% 
  group_by(measure) %>% 
  nest() %>% 
  mutate(mod = map(data, function(x) aov(val ~ fract_dim * radius, data = x)),
         res = map(mod, tidy)) %>% 
  select(measure, res) %>% 
  unnest() %>% 
  select(-p.value) %>% 
  kable(digits = 3)
```

`r tabs("aov_var", "Two-way analysis of variance for each MW measure. Note p-values are not displayed because they are artificially inflated and thus meaningless in simulation studies. We therefore concentrate on effect size.")`

# Session Info

```{r}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```