---
title: "Appendix III: forest case study"
output: 
  pdf_document:
    toc: true
    number_sections: true
header-includes:
    - \usepackage{booktabs}
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      fig.path = 'figures/',
                      dpi = 300,
                      dev = c('pdf', 'tiff', 'png'),
                      fig.width = 6.496065) # width of full page figure for Ecology Letters
```

# Required packages

In the first step, we load all of the required packages. Note that grainchanger (the package developed for this paper) can be installed using:

`devtools::install_github("laurajanegraham/grainchanger")`

Other options in this section set the order and labels for the variables for plotting and tables. 

```{r setup}
library(captioner)
library(jtools)
library(car)
library(perturb)
library(MASS)
library(grainchanger)
library(raster)
library(rgdal)
library(rgeos)
library(cowplot)
library(sf)
library(knitr)
library(GGally)
library(e1071) # optimising transformations (skewness function)
library(broom)
library(MuMIn)
library(stringr)
library(DHARMa)
library(tidyverse)

source("R/ca_glm.R")

# set up plotting options
theme_set(theme_bw(base_size = 7) + theme(strip.background = element_blank(), 
                             panel.grid.major = element_blank(),
                             panel.grid.minor = element_blank()))

varorder <- c("sprich", "winrange500", "elevrange", "elevmean", "bio1", "bio12", "bio15")

varlabel <- c("Species richness", "MW Elevation (500m)", "LS Elevation", "Mean Elevation", 
              "Temperature", "Precipitation", "Precip. seasonality")

coefforder <- c("(Intercept)", "winrange500", "elevrange", "elevmean", "elevmean:winvar500", 
                "elevmean:elevvar", "bio1", "bio12", "bio15", "I(bio1^2)", "I(bio12^2)")

coefflabel <- c("(Intercept)", "MW elevation\n(500m)", "LS elevation", "Mean elevation", 
                "Mean elevation : MW elevation", "Mean elevation : LS elevation", 
                "Temperature", "Precipitation", "Precipitation\nseasonality", 
                "Temperature\n(quadratic)", "Precipitation\n(quadratic)")

# required for captioning and numbering tables and figures
tabs <- captioner(prefix = "Table AIII.")
figs <- captioner(prefix = "Figure AIII.")
```

# Data

Note that file paths to data sources are hard coded. These will need updating to match folder structure. A search for `~/` in the document will find these. 

## Biological data

First we need to load in and spatialise the EU forest data: available for download from [figshare](https://ndownloader.figshare.com/files/6662535).

```{r euforest_data, eval = FALSE}
# we only need this step the first time - once combined with the environmental data the
# output is saved to results/forests_covariates.Rda for further use
forests <- read_csv("~/DATA/BIOLOGICAL/eu_forests/eu_forest_species.csv") %>% 
  mutate(sp_name = `SPECIES NAME`) %>% 
  dplyr::select(X, Y, sp_name)

eu_crs <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +nodefs"
forests <- SpatialPointsDataFrame(forests[,1:2], forests[,3], 
                                  proj4string = crs(eu_crs))
```

## Environmental data

Analyses will be at 0.5 degree resolution. The data to be upscaled are the elevation data from the [European Environment Agency](https://www.eea.europa.eu/data-and-maps/data/eu-dem). By cropping all datasets to the extent of the EU elevation data, we end up losing some of the data from the EU forest dataset, such as the records from Northern Africa and the Canaries. We aggregate the elevation to 100m (from 25m) for ease of computation.

We will use the moving window to upscale the variation in elevation using a radius of 500 m. We will also calculate variation in elevation at 0.5 degree resolution. As covariates, we  calculated average temperature and precipitation at 0.5 degree resolution. 

```{r envdata, eval = FALSE}
# get climate data
wc_bio <- getData('worldclim', var = "bio", res = 10, path = "~/DATA/CLIMATE/worldclim/")
wc_bio_30 <- aggregate(wc_bio, fact = 3)

# load in the elevation data
elev <- raster("~/DATA/PHYSICAL/elev/eu_dem_1.1/eudem_dem_3035_europe.tif")

# get forest and climate data in same projection as elev and crop worldclim data by the EU
# forest dataset
forests <- spTransform(forests, crs(elev))
wc_bio_30 <- projectRaster(wc_bio_30, crs = crs(elev))

# crop climate data
bounds <- extent(elev) 
wc_bio_eu <- crop(wc_bio_30, bounds)

# rasterise the EU forest data to create total species richness (the input function gets
# the total number of unique species in a cell)
forests_r <- rasterize(forests, wc_bio_eu, 
                       fun=function(x, ...){
                         length(unique(na.omit(x)))
                       })[[2]]

# create a grid for the moving window and elevation aggregation to loop
eu_grid <- as(forests_r, 'SpatialPolygonsDataFrame')

agg_cell <- function(grid, dat, cell_no, fact, fn="mean", ...) {
  cell <- grid[cell_no,]
  dat_cell <- crop(dat, cell, filename='temp_raster/temp_crop.tif', overwrite=TRUE)
  dat_cell_agg <- aggregate(dat_cell, fact, fun = fn,
                            filename='temp_raster/temp_agg.tif', overwrite=TRUE)
  zero_to_na <- function(x) ifelse(x==0, NA, x)
  dat_cell_na <- raster::calc(dat_cell_agg, zero_to_na, ...)
}

elev_cell_100 <- list()

for(cell_no in 1:length(eu_grid)) {
  fname <- paste0('temp_raster/temp_agg_',cell_no, '.tif'
  elev_cell_100[[cell_no]] <- agg_cell(eu_grid, elev, cell_no, 4,
                                       filename=fname), overwrite=TRUE)
}

# need to add the arguments to mosaic as attributes of the raster list.
rasters.mosaicargs <- elev_cell_100
names(rasters.mosaicargs) <- NULL
rasters.mosaicargs$fun <- mean
rasters.mosaicargs$filename <- '~/DATA/PHYSICAL/elev/eu_dem/eudem_100m_aggregated.tif'
rasters.mosaicargs$overwrite <- TRUE
rasters.mosaicargs$na.rm <- TRUE

elev_100 <- do.call("mosaic", rasters.mosaicargs)

# create the grid level covariates
eu_grid$elevvar <- nomove_agg(grid = eu_grid, dat = elev_100, 
                                  fn = "var", na.rm = TRUE)

eu_grid$elevmean <- nomove_agg(grid = eu_grid, dat = elev_100, 
                                   fn = "mean", na.rm = TRUE)

eu_grid$elevrange <- nomove_agg(grid = eu_grid, dat = elev_100, 
                                fn = "var_range", na.rm = TRUE)

# upscale the eu elevation data using the moving window approach
strt <- Sys.time()
eu_grid$winvar500 <- winmove_agg(eu_grid, elev_100, 500, 
                                        "rectangle", "var")
save(eu_grid, file = "temp.Rda")
run_time <- difftime(Sys.time(), strt, units = "mins")

save(run_time, file = "results/forests_runtime.Rda")

strt <- Sys.time()
eu_grid$winrange500 <- winmove_agg(eu_grid, elev_100, 500, 
                                        "rectangle", "var_range")
save(eu_grid, file = "temp.Rda")
range_run_time <- difftime(Sys.time(), strt, units = "mins")

save(range_run_time, file = "results/forests_range_runtime.Rda")

forests_pts <- spTransform(gCentroid(eu_grid, byid=TRUE), crs(elev_100))

forests_sp <- st_as_sf(eu_grid) %>% 
  bind_cols(raster::extract(wc_bio_eu, forests_pts) %>% as.tibble) %>% 
  rename(sprich = sp_name)

save(forests_sp, file="results/forests_covariates.Rda")
```

`r load("results/forests_runtime.Rda")`

Upscaling 100m resolution elevation data for Europe to 0.5 degree resolution using a 500 m radius window took: `r round(run_time, 2)` minutes. 

## Exploration and transformation

```{r reload_data}
load("results/forests_covariates.Rda")
forests_df <- forests_sp %>% as.tibble %>% select(varorder) %>% na.omit %>% 
  mutate(bio1 = bio1/10)
# /10 due to the way worldclim stores temperature data
```

What do the variables look like spatially?

```{r F4_forests_data_figure}
forests_narrow <- forests_sp %>% 
  select(varorder) %>% 
  mutate_at(.vars = vars(-sprich, -geometry), .funs = funs(scale)) %>% 
  gather(variable, value, -geometry) %>% 
  mutate(facet = "Tree species richness") %>% na.omit

sp_plot <- ggplot(forests_narrow %>% filter(variable == "sprich")) + 
  geom_sf(aes(fill = value), colour = NA) +
  coord_sf(crs = st_crs(forests_narrow), datum = NA) + 
  scale_fill_viridis_c(name = "", option = "magma") + 
  facet_wrap(~facet) + 
  theme(axis.text = element_blank(), 
        axis.line = element_blank(), 
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        legend.title.align = 0.5,
        legend.key.height=unit(6,"points"), 
        legend.key.width = unit(1.5, "line"),
        panel.border = element_blank())

covs <- forests_narrow %>% 
  filter(variable %in% varorder[-1]) %>% 
  mutate(variable = factor(variable, levels = varorder, labels = varlabel))

cov_plot <- ggplot(covs) + 
  geom_sf(aes(fill = value), colour = NA) +
  coord_sf(crs = st_crs(forests_narrow), datum = NA) + 
  scale_fill_viridis_c(name = "") + 
  facet_wrap(~variable) + 
  theme(axis.text = element_blank(), 
        axis.line = element_blank(), 
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        legend.title.align = 0.5,
        legend.key.height=unit(6,"points"), 
        legend.key.width = unit(2, "line"),
        panel.border = element_blank())

plot_grid(sp_plot, cov_plot, 
          labels = c("a)", "b)"),
          label_size = 7, 
          rel_widths = c(1, 1.4))
```

`r figs("spatial_plot", "A case study of the effect of topographic heterogeneity on tree species richness. Study area showing the spatial distribution of (a) tree species richness and (b) scaled covariates (mean = 0; standard deviation = 1).")`

How are the variables distributed and where are the correlations?

```{r pairs}
ggpairs(
  forests_df %>% select(varorder), 
  upper = list(
    continuous = wrap('cor', method = "spearman")
  ),
  lower = list(
    continuous = wrap('points', alpha = 0.3, size =0.1)
  ),
  columnLabels = varlabel
)
```

`r figs("pairs", "Pairs plot of *Garrulus glandarius* relative abundance and covariates. Correlations shown are Spearman's $\\rho$.")`

MW Elevation is the lowest correlation except for total precipitation (bio12). Highest correlation is with precipitation seasonality (bio15). Our expectation that variation in elevation would be important is supported here by the fact that the species richness correlation with mean elevation is lower. Species richness ideal for Poisson distribution; right skew to MW Elevation and LS elevation, Mean elevation, as well as the precipitation variables - need to transform. 

```{r transform}
# optimise to find optimal value for log transform
skew.score <- function(c, x) (skewness(log(x + c)))^2
cs <- tibble(winrange500 = optimise(skew.score, c(0, 20), 
                                    x = forests_df$winrange500)$minimum,
             elevrange = optimise(skew.score, c(0, 20), 
                                  x = forests_df$elevrange)$minimum,
             elevmean = optimise(skew.score, c(0, 20),
                                 x = forests_df$elevmean)$minimum,
             bio12 = optimise(skew.score, c(0, 20), 
                              x = forests_df$bio12)$minimum,
             bio15 = optimise(skew.score, c(0, 20), 
                              x = forests_df$bio15)$minimum)


forests_df_t <- select(forests_df, varorder) %>% 
  mutate(winrange500 = log(winrange500 + cs$winrange500),
         elevrange = log(elevrange + cs$elevrange),
         elevmean = log(elevmean + cs$elevmean),
         bio12 = log(bio12 + cs$bio12),
         bio15 = log(bio15 + cs$bio15))

forests_narrow_t <- gather(forests_df_t, variable, value) %>% 
  mutate(variable = factor(variable, levels = varorder, labels = varlabel))

# get mean and sd values from the log-transformed data (for back scaling)
means <- forests_df_t %>% 
  summarise_all(funs(mean, sd)) %>% 
  gather() %>% 
  separate(key, into=c("covariate", "measure")) %>% 
  spread(measure, value) %>% 
  left_join(gather(cs, covariate, c))
```

We scaled the data (mean = 0, SD = 1) so that the partial regression coefficients are comparable. 

```{r scale_data}
scale_this <- function(x) as.vector(scale(x))
forests_df_t <- mutate_at(forests_df_t, .vars = vars(-sprich), .funs = funs(scale_this))
```

# Statistical model

Our sample size is n = `r nrow(forests_df_t)`. 

Our model contains the following variables: MW Elevation, LS Elevation, mean elevation, temperature, temperature quadratic term, precipitation, precipitation quadratic term, and precipitation seasonality. We are including the quadratic terms for temperature and precipitation, due to the shape of the relationship between these variables (and based on some earlier residual diagnostics). We also include the interaction term between mean elevation and the MW & LS elevation variables. 

The model is fit to a negative binomial distribution due to overdispersion (based on earlier diagnostics). 

```{r global_model}
mod_global <- glm.nb(sprich ~ elevmean + winrange500 + elevrange + bio1 + 
                       I(bio1^2) + bio12 + I(bio12^2) + bio15, 
                     data = forests_df_t, na.action = na.fail)

res_global <- mod_global %>% coef %>% enframe(name = "variable", value = "coef") %>%
  left_join(mod_global %>% confint %>% as_tibble(rownames = "variable")) %>%
  mutate(fvariable = factor(variable, levels = coefforder, 
                            labels = gsub("\n", " ", coefflabel))) %>%
  arrange(fvariable) 

globalr2 <- 1 - (mod_global$deviance / mod_global$null.deviance)

res_global %>% select(fvariable, coef, `2.5 %`, `97.5 %`) %>% kable(digits=3)
```

`r tabs("global_model", "Results of negative binomial GLM for the full model")`

There is a negative effect of local-scale (500 m) variation in elevation (MW Elevation), but a positive effect of landscape-scale (~50km) variation in elevation (LS Elevation). 

This model explains `r round(globalr2*100, 2)`% of the deviance in tree species richness. This was calculated using D-squared. 

# Model validation

Check the model specification using the DHARMa package. 

```{r validation1}
simulationOutput <- simulateResiduals(fittedModel = mod_global, n = 250)

plotSimulatedResiduals(simulationOutput)
```
`r figs("resid", "Residual plots for checking model specification")`

```{r validation2}
par(mfrow = c(2, 3))
plotResiduals(forests_df_t$winrange500, 
              simulationOutput$scaledResiduals, 
              xlab = "MW elevation (500m)")

plotResiduals(forests_df_t$elevrange, 
              simulationOutput$scaledResiduals, 
              xlab = "LS elevation")

plotResiduals(forests_df_t$elevmean, 
              simulationOutput$scaledResiduals, 
              xlab = "Mean elevation")

plotResiduals(forests_df_t$bio1, 
              simulationOutput$scaledResiduals, 
              xlab = "Temperature")

plotResiduals(forests_df_t$bio12, 
              simulationOutput$scaledResiduals, 
              xlab = "Precipitation")

plotResiduals(forests_df_t$bio15, 
              simulationOutput$scaledResiduals, 
              xlab = "Precipitation seasonality")
```

`r figs("resid_pred", "Residual vs predictor plots for checking model specification")`

Based on the residual diagnostics, have gone with a negative binomial model due to overdispersion. The earlier version of the diagnostics also found patterns with temperature (bio1) and precipitation (bio12), hence the inclusion of their quadratic terms. The lowest fitted value is `r round(min(mod_global$fitted.values), 2)` and the highest is `r round(max(mod_global$fitted.values), 2)`.

# Collinearity diagnostics

Due to the high correlation in the data, we will use some in-depth collinearity diagnostics

1. Variance inflation factor (not overly relevant due to large sample size)
2. Condition index and variance decomposition
3. Stability under perturbation analysis
4. Stability under data sub-sampling
5. Collinearity in regression coefficients

## Variance inflation factor

```{r vif}
vif(mod_global) %>% kable(digits = 2, col.names = c("VIF"))
```

`r tabs("vif", "Variance inflation factors for each term in the global model")`

Generally low. All below 10 except LS elevation, and even then the large sample size means this is not that large. See [O'Brien 2007](https://link.springer.com/article/10.1007/s11135-006-9018-6) for warnings on rule-of-thumb application of multicollinearity diagnostics. 

## Condition index and variance decomposition

See [Callaghan and Chen 2008](http://pareonline.net/getvn.asp?v=13&n=5) for information on how to interpret condition indices and variance decomposition (but use D. Belsley, E. Kuh, and R. Welsch (1980). Regression Diagnostics. Wiley.
 as citation). In short, rows in the below table with a high condition index (first column, high is > 10 - moderate to strong collinearity, > 30 - severe collinearity) which are associated with high variance of regression estimate (the rest of the table) will cause a problem in the analysis. 

```{r test_collin}
mod_diag <- colldiag(mod_global) %>% lapply(as.data.frame)
mod_diag <- do.call("cbind", mod_diag)
names(mod_diag) <- c("CI", "Intercept", "Mean elev", "MW elev", "LS elev", 
                     "Temp", "Temp^2", "Precip", "Precip^2", "P season")
kable(mod_diag, digits = 3)
```

`r tabs("condition", "Condition index and variance decomposition")`

The highest condition index is `r round(max(mod_diag$CI), 2)`, which is in the "weak collinearity" range. Model looks fine by these diagnostics. There is high variance decomposition associated with the MW & LS Elevation coefficient estimates, but given the CI is within "weak collinearity range", this should be okay. We will check this with some tests on the data. 

## Stability under perturbation analysis

We will add some random noise to the two environmental heterogeneity measures to evaluate collinearity. 

```{r perturb}
attach(forests_df_t)
perturb_mod <- perturb(mod_global, 
                       pvars = c("winrange500", "elevrange"), 
                       prange=c(0.1,0.1))
detach(forests_df_t)

perturb_mod$coeff.table %>% as.tibble %>% 
  gather(variable, value) %>% 
  group_by(variable) %>% 
  summarise(mean_val = mean(value), 
            sd_val = sd(value), 
            min_val = min(value), 
            max_val = max(value)) %>% 
  mutate(variable = factor(variable, levels = coefforder, 
                           labels = gsub("\n", " ", coefflabel))) %>% 
  arrange(variable) %>% 
  kable(digits = 3)
```

`r tabs("perturb", "Results of perturbation analysis. Random noise was added to the two Shannon measures to the range of 0.1")`

Biggest changes are to the MW & LS values, but this does not change the conclusions and the SD is still reasonably small (SD is ~ 10% of the coefficient estimate). 

## Stability under data sub-sampling

Now let's test this by checking the model results are stable under subsampling. 

NB This will reduce the power to detect significant relationships (increase Type II errors).

```{r model_subsample}
model_subsample <-function(x, dat, n) { 
  
  dat <- sample_n(dat, n)
  
  mod <- glm.nb(sprich ~ elevmean + winrange500 + elevrange + bio1 + I(bio1^2) + 
                  bio12 + I(bio12^2) + bio15, 
                data = dat, na.action = na.fail)
  
  res <- mod %>% coef %>% enframe(name = "variable", value = "coef") %>%
    left_join(mod %>% confint %>% as_tibble(rownames = "variable")) %>%
    mutate(fvariable = factor(variable, levels = coefforder, 
                              labels = gsub("\n", " ", coefflabel))) %>%
    arrange(fvariable) 
  
  r2 <- 1 - (mod$deviance / mod$null.deviance)
  
  res %>% select(fvariable, coef, `2.5 %`, `97.5 %`) %>% mutate(D = r2)
}

n <- 1500
nsim <- 100
out <- map_dfr(1:nsim, ~model_subsample(.x, forests_df_t, n))

out_narrow <- out %>% gather(measure, value, -D, -fvariable) %>% 
  mutate(measure = factor(measure, labels = c("LCI", "UCI", "Coefficient")),
         measure = factor(measure, levels = c("LCI", "Coefficient", "UCI"))) %>% 
  filter(grepl("elevation", fvariable))

res_narrow <- res_global %>% 
  filter(variable %in% c("winrange500", "elevrange", "elevmean")) %>% 
  select(fvariable, Coefficient = coef, LCI = `2.5 %`, UCI = `97.5 %`) %>% 
  gather(measure, value, -fvariable)
```

```{r subsample_plot}
ggplot(out_narrow, aes(x = "fvariable", y = value)) + 
  geom_jitter() + 
  facet_grid(measure~fvariable) + 
  geom_hline(data = res_narrow, aes(yintercept = value), colour = "red") + 
  labs(x = "", y = "Coefficient estimate") + 
  theme(axis.text.x=element_blank())
```

`r figs("subsample", "Results of subsampling analysis. For 100 replicates, 1500 points were subsampled from the total dataset and the regression calculated. Red lines show the value of the coefficient when the regression is calculated using the full dataset")`

In `r figs("subsample", display = "cite")`, each point is the estimate for the model parameterised with one of the 100 samples of n = `r n` from the full dataset. The red line shows the estimate from the model parameterised using the full dataset (n = `r nrow(forests_df_t)`). The estimates are reasonably robust to sub-sampling the data (not much variation in estimates and very few changes to non-significant - precipitation is the exception here, but this was close to non-significant previously, reducing power has meant this cannot be estimated).

```{r comp_r2}
ggplot(data = out, aes(x = D)) + 
  geom_histogram() + 
  geom_vline(xintercept = globalr2)
```

`r figs("subsample_r2", "$R^2$ distribution for each replicate in the subsampling analysis.")`

## Collinearity in regression coefficients

Finally, we need to check that we do not have extreme collinearity in the parameter estimates. 

```{r coef_colin}
coef_cov <- cov2cor(vcov(mod_global)) 

coef_cov%>% 
  as.tibble(rownames = "variable") %>% 
  kable(digits = 2)
```

`r tabs("coef_colin", "Pairwise correlations between coefficient estimates from the full model")`

Correlation between LS elevation and MW elevation (500m), but not super high. 

# Commonality analysis

Although the model does not display multicollinearity despite high correlation between the two Shannon measures, we will apply commonality analysis. This approach allows us to understand the importance of different variables despite any collinearity in the model. See [Kraha et al. 2012](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3303138/) and [Ray-Mukherjee et al. 2014](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.12166) for explanation of the approach. For each variable we will calculate: 

1. *Beta coefficients* the standardised partial regression coefficients
2. *Structural coefficients* Squared Pearson correlation between the variable and the fitted values from the model
3. *Unique variance* Amount of variance uniquely accounted for by the variable
4. *Common variance* Amount of variance in common with other variables
5. *Total variance* Total amount of variance accounted for by the variable

```{r commonality}
ca_table <- res_global %>% 
  filter(fvariable != "Intercept") %>% 
  # structural coefficients
  mutate(r_s = map_dbl(variable, function(x) {
    out <- cor(model.matrix(mod_global)[,x], mod_global$fitted.values)
  }),
  r_s2 = r_s^2) %>% 
  # unique, common and total variance
  inner_join(calc_commonality(mod_global)$CCTotalbyVar %>% 
               as.tibble(rownames = "variable")) %>% 
  select(fvariable, beta = coef, `2.5 %`, `97.5 %`, r_s, r_s2, Unique, Common, Total) %>% 
  arrange(fvariable)

write_csv(ca_table, "tables/forests_commonality.csv")

kable(ca_table, digits = 3)
```

`r tabs("comm_global", "Commonality analysis for the global model")`

# Final results and plots

We will now plot the main effects from the full model. 

```{r F6_forests_results, fig.width = 4.33071, fig.height = 6.496065}
# need to predict from the model then convert to the original scales
pred_vals <- bind_rows(
  make_predictions(mod_global, pred = "elevmean", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = elevmean) %>% 
    mutate(covariate = "elevmean"),
  make_predictions(mod_global, pred = "elevrange", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = elevrange) %>% 
    mutate(covariate = "elevrange"),
    make_predictions(mod_global, pred = "winrange500", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = winrange500) %>% 
    mutate(covariate = "winrange500"),
  make_predictions(mod_global, pred = "bio1", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = bio1) %>% 
    mutate(covariate = "bio1"),
    make_predictions(mod_global, pred = "bio12", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = bio12) %>% 
    mutate(covariate = "bio12"),
    make_predictions(mod_global, pred = "bio15", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = bio15) %>% 
    mutate(covariate = "bio15")) %>% 
  as_tibble %>% 
  inner_join(means) %>% 
  mutate(pred = pred*sd + mean, 
         pred = case_when(!is.na(c) ~ exp(pred) - c,
                          TRUE ~ pred))

# plot the results
winrange_plot <- ggplot(pred_vals %>% filter(covariate == "winrange500"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "MW elevation (500m)",
       y = "")

range_plot <- ggplot(pred_vals %>% filter(covariate == "elevrange"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "LS elevation",
       y = "")

mean_plot <- ggplot(pred_vals %>% filter(covariate == "elevmean"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "Mean elevation",
        y = expression("Tree species richness (" %+-% "95% CI)"))

bio1_plot <- ggplot(pred_vals %>% filter(covariate == "bio1"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = expression("Temperature (" * degree * "C)"),
       y = "")

bio12_plot <- ggplot(pred_vals %>% filter(covariate == "bio12"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "Total precipitation (mm)",
       y = "")

bio15_plot <- ggplot(pred_vals %>% filter(covariate == "bio15"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "Precipitation seasonality",
       y = "")

plot_grid(winrange_plot, range_plot, mean_plot, 
                      bio1_plot, bio12_plot, bio15_plot, 
                      ncol = 2)
```

`r figs("res_plot", "Main effect estimates for the full model")`

# Session Info
```{r}
session <- devtools::session_info()
session[[1]]
session[[2]] %>% kable
```

