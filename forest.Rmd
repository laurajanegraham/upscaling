---
title: "Appendix III: forest case study"
output: 
  pdf_document:
    toc: true
    number_sections: true
header-includes:
    - \usepackage{booktabs}
    - \usepackage{caption}
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Required packages

In the first step, we load all of the required packages. Note that grainchanger (the package developed for this paper) can be installed using:

`devtools::install_github("laurajanegraham/grainchanger")`

Other options in this section set the order and labels for the variables for plotting and tables. 

```{r setup}
library(captioner)
library(jtools)
library(car)
library(perturb)
library(MASS)
library(grainchanger)
library(raster)
library(rgdal)
library(rgeos)
library(cowplot)
library(sf)
library(knitr)
library(GGally)
library(e1071) # optimising transformations (skewness function)
library(broom)
library(MuMIn)
library(stringr)
library(DHARMa)
library(tidyverse)

source("R/ca_glm.R")

# set up plotting options
theme_set(theme_classic() + theme(strip.background = element_blank()))

varorder <- c("sprich", "winrange500", "elevrange", "elevmean", "bio1", "bio12", "bio15")

varlabel <- c("Species richness", "MW Elevation (500m)", "LS Elevation", "Mean Elevation", 
              "Temperature", "Precipitation", "Precip. seasonality")

coefforder <- c("(Intercept)", "winrange500", "elevrange", "elevmean", "elevmean:winvar500", 
                "elevmean:elevvar", "bio1", "bio12", "bio15", "I(bio1^2)", "I(bio12^2)")

coefflabel <- c("(Intercept)", "MW elevation\n(500m)", "LS elevation", "Mean elevation", 
                "Mean elevation : MW elevation", "Mean elevation : LS elevation", 
                "Temperature", "Precipitation", "Precipitation\nseasonality", 
                "Temperature\n(quadratic)", "Precipitation\n(quadratic)")
```

# Data

## Biological data

First we need to load in and spatialise the EU forest data: available for download from [figshare](https://ndownloader.figshare.com/files/6662535).

```{r euforest_data, eval = FALSE}
# we only need this step the first time - once combined with the environmental data the
# output is saved to results/forests_covariates.Rda for further use
forests <- read_csv("~/DATA/BIOLOGICAL/eu_forests/eu_forest_species.csv") %>% 
  mutate(sp_name = `SPECIES NAME`) %>% 
  dplyr::select(X, Y, sp_name)

eu_crs <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +nodefs"
forests <- SpatialPointsDataFrame(forests[,1:2], forests[,3], 
                                  proj4string = crs(eu_crs))
```

## Environmental data

Analyses will be at 0.5 degree resolution. The data to be upscaled are the elevation data from the [European Environment Agency](https://www.eea.europa.eu/data-and-maps/data/eu-dem). By cropping all datasets to the extent of the EU elevation data, we end up losing some of the data from the EU forest dataset, such as the records from Northern Africa and the Canaries. We aggregate the elevation to 100m (from 25m) for ease of computation.

We will use the moving window to upscale the variation in elevation using a radius of 500 m. We will also calculate variation in elevation at 0.5 degree resolution. As covariates, we  calculated average temperature and precipitation at 0.5 degree resolution. 

```{r envdata, eval = FALSE}
# get climate data
wc_bio <- getData('worldclim', var = "bio", res = 10, path = "~/DATA/CLIMATE/worldclim/")
wc_bio_30 <- aggregate(wc_bio, fact = 3)

# load in the elevation data
elev <- raster("~/DATA/PHYSICAL/elev/eu_dem_1.1/eudem_dem_3035_europe.tif")

# get %>% forest and climate data in same projection as elev and crop worldclim data by the EU
# forest dataset
forests <- spTransform(forests, crs(elev))
wc_bio_30 <- projectRaster(wc_bio_30, crs = crs(elev))

# crop climate data
bounds <- extent(elev) 
wc_bio_eu <- crop(wc_bio_30, bounds)

# rasterise the EU forest data to create total species richness (the input function gets
# the total number of unique species in a cell)
forests_r <- rasterize(forests, wc_bio_eu, 
                       fun=function(x, ...){
                         length(unique(na.omit(x)))
                       })[[2]]

# create a grid for the moving window and elevation aggregation to loop
eu_grid <- as(forests_r, 'SpatialPolygonsDataFrame')

agg_cell <- function(grid, dat, cell_no, fact, fn="mean", ...) {
  cell <- grid[cell_no,]
  dat_cell <- crop(dat, cell, filename='temp_raster/temp_crop.tif', overwrite=TRUE)
  dat_cell_agg <- aggregate(dat_cell, fact, fun = fn,
                            filename='temp_raster/temp_agg.tif', overwrite=TRUE)
  zero_to_na <- function(x) ifelse(x==0, NA, x)
  dat_cell_na <- raster::calc(dat_cell_agg, zero_to_na, ...)
}

elev_cell_100 <- list()

for(cell_no in 1:length(eu_grid)) {
  fname <- paste0('temp_raster/temp_agg_',cell_no, '.tif'
  elev_cell_100[[cell_no]] <- agg_cell(eu_grid, elev, cell_no, 4,
                                       filename=fname), overwrite=TRUE)
}

# need to add the arguments to mosaic as attributes of the raster list.
rasters.mosaicargs <- elev_cell_100
names(rasters.mosaicargs) <- NULL
rasters.mosaicargs$fun <- mean
rasters.mosaicargs$filename <- '~/DATA/PHYSICAL/elev/eu_dem/eudem_100m_aggregated.tif'
rasters.mosaicargs$overwrite <- TRUE
rasters.mosaicargs$na.rm <- TRUE

elev_100 <- do.call("mosaic", rasters.mosaicargs)



# create the grid level covariates
eu_grid$elevvar <- nomove_agg(grid = eu_grid, dat = elev_100, 
                                  fn = "var", na.rm = TRUE)

eu_grid$elevmean <- nomove_agg(grid = eu_grid, dat = elev_100, 
                                   fn = "mean", na.rm = TRUE)

eu_grid$elevrange <- nomove_agg(grid = eu_grid, dat = elev_100, 
                                fn = "var_range", na.rm = TRUE)

# upscale the eu elevation data using the moving window approach
strt <- Sys.time()
eu_grid$winvar500 <- winmove_agg(eu_grid, elev_100, 500, 
                                        "rectangle", "var")
save(eu_grid, file = "temp.Rda")
run_time <- difftime(Sys.time(), strt, units = "mins")

save(run_time, file = "results/forests_runtime.Rda")

strt <- Sys.time()
eu_grid$winrange500 <- winmove_agg(eu_grid, elev_100, 500, 
                                        "rectangle", "var_range")
save(eu_grid, file = "temp.Rda")
range_run_time <- difftime(Sys.time(), strt, units = "mins")

save(range_run_time, file = "results/forests_range_runtime.Rda")

forests_pts <- spTransform(gCentroid(eu_grid, byid=TRUE), crs(elev_100))

forests_sp <- st_as_sf(eu_grid) %>% 
  bind_cols(raster::extract(wc_bio_eu, forests_pts) %>% as.tibble) %>% 
  rename(sprich = sp_name)

save(forests_sp, file="results/forests_covariates.Rda")
```


`r load("results/forests_runtime.Rda")`
Upscaling 100m resolution elevation data for Europe to 0.5 degree resolution using a 500 m radius window took:  `r round(run_time, 2)` minutes. 

## Exploration and transformation

```{r reload_data}
load("results/forests_covariates.Rda")
forests_df <- forests_sp %>% as.tibble %>% select(varorder) %>% na.omit %>% 
  mutate(bio1 = bio1/10)
# /10 due to the way worldclim stores temperature data
```

What do the variables look like spatially?

```{r spatial_plot}
forests_narrow <- forests_sp %>% 
  select(varorder) %>% 
  mutate_at(.vars = vars(-sprich, -geometry), .funs = funs(scale)) %>% 
  gather(variable, value, -geometry) %>% 
  mutate(facet = "Tree species richness") %>% na.omit

sp_plot <- ggplot(forests_narrow %>% filter(variable == "sprich")) + 
  geom_sf(aes(fill = value), colour = NA) +
  coord_sf(crs = st_crs(forests_narrow), datum = NA) + 
  scale_fill_viridis_c(name = "", option = "magma") + 
  facet_wrap(~facet) + 
  theme(axis.text = element_blank(), axis.line = element_blank(), 
        axis.ticks = element_blank(),
        legend.position = "bottom", legend.title.align = 0.5,
        legend.key.height=unit(6,"points"), legend.key.width = unit(1.5, "line"))

save(sp_plot, file = "results/forests_response_plot.Rda")

covs <- forests_narrow %>% 
  filter(variable %in% varorder[-1]) %>% 
  mutate(variable = factor(variable, levels = varorder, labels = varlabel))

cov_plot <- ggplot(covs) + 
  geom_sf(aes(fill = value), colour = NA) +
  coord_sf(crs = st_crs(forests_narrow), datum = NA) + 
  scale_fill_viridis_c(name = "") + facet_wrap(~variable) + 
  theme(axis.text = element_blank(), axis.line = element_blank(), 
        axis.ticks = element_blank(),
        legend.position = "bottom", legend.title.align = 0.5,
        legend.key.height=unit(6,"points"), legend.key.width = unit(2, "line"))

save(cov_plot, file = "results/forests_cov_plot.Rda")

data_plot <- plot_grid(sp_plot, cov_plot, labels = c("a)", "b)"),
                          label_size = 10, rel_widths = c(1, 1.4))

save_plot("~/Google Drive/SCALEFORES/Papers/Upscaling/figures/F5_forests_data_figure.jpg", 
          data_plot, base_width = 6.81102)

data_plot
```

How are the variables distributed and where are the correlations?

```{r pairs, fig.width = 10, fig.height = 10}
ggpairs(
  forests_df %>% select(varorder), 
  upper = list(
    continuous = wrap('cor', method = "spearman")
  ),
  columnLabels = varlabel
)
```

MW Elevation is the lowest correlation except for total precipitation (bio12). Highest correlation is with precipitation seasonality (bio15). Our expectation that variation in elevation would be important is supported here by the fact that the species richness correlation with mean elevation is lower. Species richness ideal for Poisson distribution; right skew to MW Elevation and LS elevation, Mean elevation, as well as the precipitation variables - need to transform. 

```{r transform}
# optimise to find optimal value for log transform
skew.score <- function(c, x) (skewness(log(x + c)))^2
cs <- tibble(winrange500 = optimise(skew.score, c(0, 20), x = forests_df$winrange500)$minimum,
             elevrange = optimise(skew.score, c(0, 20), x = forests_df$elevrange)$minimum,
             elevmean = optimise(skew.score, c(0, 20), x = forests_df$elevmean)$minimum,
             bio12 = optimise(skew.score, c(0, 20), x = forests_df$bio12)$minimum,
             bio15 = optimise(skew.score, c(0, 20), x = forests_df$bio15)$minimum)


forests_df_t <- select(forests_df, varorder) %>% 
  mutate(winrange500 = log(winrange500 + cs$winrange500),
         elevrange = log(elevrange + cs$elevrange),
         elevmean = log(elevmean + cs$elevmean),
         bio12 = log(bio12 + cs$bio12),
         bio15 = log(bio15 + cs$bio15))

forests_narrow_t <- gather(forests_df_t, variable, value) %>% 
  mutate(variable = factor(variable, levels = varorder, labels = varlabel))

# get mean and sd values from the log-transformed data (for back scaling)
means <- forests_df_t %>% 
  summarise_all(funs(mean, sd)) %>% 
  gather() %>% 
  separate(key, into=c("covariate", "measure")) %>% 
  spread(measure, value) %>% 
  left_join(gather(cs, covariate, c))
```

We scaled the data (mean = 0, sd = 1) so that the partial regression coefficients are comparable. 

```{r scale_data}
scale_this <- function(x) as.vector(scale(x))
forests_df_t <- mutate_at(forests_df_t, .vars = vars(-sprich), .funs = funs(scale_this))
```

# Statistical model

Our sample size is n = `r nrow(forests_df_t)`. 

Our model contains the following variables: MW Elevation, LS Elevation, mean elevation, temperature, temperature quadratic term, precipitation, precipitation quadratic term, and precipitation seasonality. We are including the quadratic terms for temperature and precipitation, due to the shape of the relationship between these variables (and based on some earlier residual diagnostics). We also include the interaction term between mean elevation and the MW & LS elevation variables. 

The model is fit to a negative binomial distribution due to overdispersion (based on earlier diagnostics). 

```{r global_model}
mod_global <- glm.nb(sprich ~ elevmean + winrange500 + elevrange + bio1 + 
                       I(bio1^2) + bio12 + I(bio12^2) + bio15, 
                     data = forests_df_t, na.action = na.fail)

res_global <- mod_global %>% coef %>% enframe(name = "variable", value = "coef") %>%
  left_join(mod_global %>% confint %>% as_tibble(rownames = "variable")) %>%
  mutate(fvariable = factor(variable, levels = coefforder, 
                            labels = gsub("\n", " ", coefflabel))) %>%
  arrange(fvariable) 

globalr2 <- 1 - (mod_global$deviance / mod_global$null.deviance)

res_global %>% select(fvariable, coef, `2.5 %`, `97.5 %`) %>% kable(digits=3)
```

There is a negative effect of local-scale (500 m) variation in elevation (MW Elevation), but a positive effect of landscape-scale (~50km) variation in elevation (LS Elevation). 

This model explains `r round(globalr2*100, 2)`% of the deviance in tree species richness. This was calculated using D-squared. 

# Model validation

Check the model specification using the DHARMa package. 

```{r validation, fig.height = 8}
simulationOutput <- simulateResiduals(fittedModel = mod_global, n = 250)

plotSimulatedResiduals(simulationOutput)

plotResiduals(forests_df_t$winrange500, 
              simulationOutput$scaledResiduals, 
              xlab = "MW elevation (500m)")

plotResiduals(forests_df_t$elevrange, 
              simulationOutput$scaledResiduals, 
              xlab = "LS elevation")

plotResiduals(forests_df_t$elevmean, 
              simulationOutput$scaledResiduals, 
              xlab = "Mean elevation")

plotResiduals(forests_df_t$bio1, 
              simulationOutput$scaledResiduals, 
              xlab = "Temperature")

plotResiduals(forests_df_t$bio12, 
              simulationOutput$scaledResiduals, 
              xlab = "Precipitation")

plotResiduals(forests_df_t$bio15, 
              simulationOutput$scaledResiduals, 
              xlab = "Precipitation seasonality")
```

Based on the residual diagnostics, have gone with a negative binomial model due to overdispersion. The earlier version of the diagnostics also found patterns with temperature (bio1) and precipitation (bio12), hence the inclusion of their quadratic terms.

# Collinearity diagnostics

Due to the high correlation in the data, we will use some in-depth collinearity diagnostics

1. Variance inflation factor (not overly relevant due to large sample size)
2. Condition index and variance decomposition
3. Stability under perturbation analysis
4. Stability under data sub-sampling
5. Collinearity in regression coefficients

## Variance inflation factor

```{r}
vif(mod_global)
```

Generally low. All below 10 except elevrange, and even then the large sample size means this is not that large. See [O'Brien 2007](https://link.springer.com/article/10.1007/s11135-006-9018-6) for warnings on rule-of-thumb application of multicollinearity diagnostics. 

## Condition index and variance decomposition

See [Callaghan and Chen 2008](http://pareonline.net/getvn.asp?v=13&n=5) for information on how to interpret condition indices and variance decomposition (but use D. Belsley, E. Kuh, and R. Welsch (1980). Regression Diagnostics. Wiley.
 as citation). In short, rows in the below table with a high condition index (first column, high is > 10 - moderate to strong collinearity, > 30 - severe collinearity) which are associated with high variance of regression estimate (the rest of the table) will cause a problem in the analysis. 

```{r test_collin_fullmod}
mod_diag <- colldiag(mod_global) %>% lapply(as.data.frame)
mod_diag <- do.call("cbind", mod_diag)
names(mod_diag) <- c("CI", "Intercept", "Mean elev", "MW elev", "LS elev", 
                     "Temp", "Temp^2", "Precip", "Precip^2", "P season")
kable(mod_diag, digits = 3)
```

The highest condition index is `r round(max(mod_diag$CI), 2)`, which is in the "weak collinearity" range. Model looks fine by these diagnostics. There is high variance decomposition associated with the MW & LS Elevation coefficient estimates, but given the CI is within "weak collinearity range", this should be okay. We will check this with some tests on the data. 

## Stability under perturbation analysis

We will add some random noise to the two environmental heterogeneity measures to evaluate collinearity. 

```{r}
attach(forests_df_t)
perturb_mod <- perturb(mod_global, pvars = c("winrange500", "elevrange"), prange=c(0.1,0.1))
detach(forests_df_t)

perturb_mod$coeff.table %>% as.tibble %>% 
  gather(variable, value) %>% 
  group_by(variable) %>% 
  summarise(mean_val = mean(value), 
            sd_val = sd(value), 
            min_val = min(value), 
            max_val = max(value)) %>% 
  mutate(variable = factor(variable, levels = coefforder, 
                           labels = gsub("\n", " ", coefflabel))) %>% 
  arrange(variable) %>% 
  kable(digits = 3)

```

Biggest changes are to the MW & LS values, but this does not change the conclusions and the sd is still reasonably small (SD is ~ 10% of the coefficient estimate). 

## Stability under data sub-sampling

Now let's test this by checking the model results are stable under subsampling. 

NB This will reduce the power to detect significant relationships (increase Type II errors).

```{r model_subsample, fig.width = 12}
model_subsample <-function(x, dat, n) { 
  
  dat <- sample_n(dat, n)
  
  mod <- glm.nb(sprich ~ elevmean + winrange500 + elevrange + bio1 + I(bio1^2) + 
                  bio12 + I(bio12^2) + bio15, 
                data = dat, na.action = na.fail)
  
  res <- mod %>% coef %>% enframe(name = "variable", value = "coef") %>%
    left_join(mod %>% confint %>% as_tibble(rownames = "variable")) %>%
    mutate(fvariable = factor(variable, levels = coefforder, 
                              labels = gsub("\n", " ", coefflabel))) %>%
    arrange(fvariable) 
  
  r2 <- 1 - (mod$deviance / mod$null.deviance)
  
  res %>% select(fvariable, coef, `2.5 %`, `97.5 %`) %>% mutate(D = r2)
}

n <- 1500
nsim <- 100
out <- map_dfr(1:nsim, ~model_subsample(.x, forests_df_t, n))

ggplot(data = out, aes(x = D)) + 
  geom_histogram() + 
  geom_vline(xintercept = globalr2)

out_ns <- out %>% mutate(signif = ifelse((`2.5 %` > 0 & `97.5 %` > 0) | 
                                           (`2.5 %` < 0 & `97.5 %` < 0), 1, 0)) %>% 
  filter(signif == 0)

out_narrow <- out %>% gather(measure, value, -D, -fvariable) %>% 
  mutate(measure = factor(measure, labels = c("LCI", "UCI", "Coefficient")),
         measure = factor(measure, levels = c("LCI", "Coefficient", "UCI"))) %>% 
  filter(grepl("elevation", fvariable))

res_narrow <- res_global %>% gather(measure, value, -fvariable, -variable) %>% 
  mutate(measure = factor(measure, labels = c("LCI", "UCI", "Coefficient")),
         measure = factor(measure, levels = c("LCI", "Coefficient", "UCI"))) %>% 
  filter(grepl("elevation", fvariable))

ggplot(out_narrow, aes(x = "fvariable", y = value)) + 
  geom_jitter() + 
  facet_grid(measure~fvariable) + 
  geom_hline(data = res_narrow, aes(yintercept = value), colour = "red") + 
  labs(x = "Variable", y = "Coefficient estimate") + 
  theme(axis.text.x=element_blank())

out_summary <- group_by(out_narrow, fvariable, measure) %>% 
  summarise(mean_val = mean(value), 
            min_val = min(value), 
            max_val = max(value), 
            sd_val = sd(value)) 

out_summary %>% kable(digits = 3)

out_ns <- filter(out, `2.5 %` < 0 & `97.5 %` > 0) %>% 
  group_by(fvariable) %>% 
  summarise(prop_ns = n() / nsim) 

out_ns %>% kable(digits = 3)
```

In this plot, each point is the estimate for the model parameterised with one of the 100 samples of n = `r n` from the full dataset. The red line shows the estimate from the model parameterised using the full dataset (n = `r nrow(forests_df_t)`). The estimates are reasonably robust to subsampling the data (not much variation in estimates and very few changes to non-significant - precipitation is the exception here, but this was close to non-significant previously, reducing power has meant this cannot be estimated).

## Collinearity in regression coefficients

I've tested this here due to concern that the coefficients for MW Elevation and LS Elevation look like mirror images of each other. 

```{r}
coef_cov <- cov2cor(vcov(mod_global)) 

coef_cov%>% 
  as.tibble(rownames = "variable") %>% 
  #mutate(fvariable = factor(variable, levels = coefforder, 
  #                          labels = gsub("\n", " ", coefflabel))) %>%
  #arrange(fvariable) %>% 
  kable(digits = 2)
```

Correlation between elevrange and winrange, but not super high. 

# Commonality analysis

Although the model does not display multicollinearity despite high correlation between the two Shannon measures, we will apply commonality analysis. This approach allows us to understand the importance of different variables despite any collinearity in the model. See [Kraha et al. 2012](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3303138/) and [Ray-Mukherjee et al. 2014](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.12166) for explanation of the approach. For each variablem we will calculate: 

1. *Beta coefficients* the standardised partial regression coefficients
2. *Structural coefficients* Squared Pearson correlation between the variable and the fitted values from the model
3. *Unique variance* Amount of variance uniquely accounted for by the variable
4. *Common variance* Amount of variance in common with other variables
5. *Total variance* Total amount of variance accounted for by the variable

```{r}
ca_table <- res_global %>% 
  filter(fvariable != "Intercept") %>% 
  # structural coefficients
  mutate(r_s = map_dbl(variable, function(x) {
    out <- cor(model.matrix(mod_global)[,x], mod_global$fitted.values)
  }),
  r_s2 = r_s^2) %>% 
  # unique, common and total variance
  inner_join(calc_commonality(mod_global)$CCTotalbyVar %>% 
               as.tibble(rownames = "variable")) %>% 
  select(fvariable, beta = coef, `2.5 %`, `97.5 %`, r_s, r_s2, Unique, Common, Total) %>% 
  arrange(fvariable)

kable(ca_table, digits = 3)
```

# Final results and plots

We will now plot the main effects from the full model. 

```{r mod_vis, fig.width = 4.33071, fig.height = 6.496065}
# need to predict from the model then convert to the original scales
pred_vals <- bind_rows(
  make_predictions(mod_global, pred = "elevmean", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = elevmean) %>% 
    mutate(covariate = "elevmean"),
  make_predictions(mod_global, pred = "elevrange", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = elevrange) %>% 
    mutate(covariate = "elevrange"),
    make_predictions(mod_global, pred = "winrange500", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = winrange500) %>% 
    mutate(covariate = "winrange500"),
  make_predictions(mod_global, pred = "bio1", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = bio1) %>% 
    mutate(covariate = "bio1"),
    make_predictions(mod_global, pred = "bio12", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = bio12) %>% 
    mutate(covariate = "bio12"),
    make_predictions(mod_global, pred = "bio15", interval = TRUE)$predicted %>% 
    select(sprich, ymax, ymin, pred = bio15) %>% 
    mutate(covariate = "bio15")) %>% 
  as_tibble %>% 
  inner_join(means) %>% 
  mutate(pred = pred*sd + mean, 
         pred = case_when(!is.na(c) ~ exp(pred) - c,
                          TRUE ~ pred))

# plot the results
winrange_plot <- ggplot(pred_vals %>% filter(covariate == "winrange500"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "MW elevation (500m)",
       y = "")

range_plot <- ggplot(pred_vals %>% filter(covariate == "elevrange"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "LS elevation",
       y = "")

mean_plot <- ggplot(pred_vals %>% filter(covariate == "elevmean"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "Mean elevation",
        y = expression("Tree species richness (" %+-% "95% CI)"))

bio1_plot <- ggplot(pred_vals %>% filter(covariate == "bio1"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = expression("Temperature (" * degree * "C)"),
       y = "")

bio12_plot <- ggplot(pred_vals %>% filter(covariate == "bio12"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "Total precipitation (mm)",
       y = "")

bio15_plot <- ggplot(pred_vals %>% filter(covariate == "bio15"), 
                        aes(x = pred, y = sprich)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = ymin, ymax = ymax), alpha = 0.2) + 
  scale_y_continuous(limits = c(0, 75), breaks = seq(from = 0, to = 75, by = 15)) + 
  labs(x = "Precipitation seasonality",
       y = "")

res_plot <- plot_grid(winrange_plot, range_plot, mean_plot, 
                      bio1_plot, bio12_plot, bio15_plot, 
                      ncol = 2)
save_plot("~/Google Drive/SCALEFORES/Papers/Upscaling/figures/FX_forest_results.jpg", 
          res_plot, base_width = 4.33071, base_height = 6.496065)
res_plot
```


# Session Info
```{r}
devtools::session_info()
```

