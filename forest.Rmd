---
title: "Upscaling: Forest Case Study"
author: "Laura Graham"
output: 
  html_document:
    toc: true
bibliography: C:\Users\lg1u16\Documents\mendeley_bibtex\library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
library(winmoveR)
library(raster)
library(rgdal)
library(rgeos)
library(ggmap)
library(cowplot)
library(sf)
library(tidyverse)

varorder <- c("sprich", "winvar2000", "elevvar", "bio1", "bio12", "bio15")
coefforder <- c("winvar2000", "elevvar", "bio1", "bio12", "bio15")
coefflabels <- c("MW Elevation (2km)", "LS Elevation", "Temperature", "Precipitation", "Precipitation\nseasonality")
```

# Case study 2: Forest 

## Data

### EU forest data

First we need to load in and spatialise the EU forest data. These are data from @Mauri2017. Available for dowload on [figshare](https://ndownloader.figshare.com/files/6662535)
```{r euforest_data}
forests <- read_csv("../DATA/eu_forests/eu_forest_species.csv") %>% 
  mutate(sp_name = `SPECIES NAME`) %>% 
  dplyr::select(X, Y, sp_name)

forests <- SpatialPointsDataFrame(forests[,1:2], forests[,3], proj4string = crs("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"))
```

### Environmental data

The data to be upscaled are the elevation data from the [European Environment Agency](https://www.eea.europa.eu/data-and-maps/data/eu-dem). Note that these are in a specific European projection: European Grid: ETRS89-LAEA. All other datasets will be transformed to this projection. By cropping all datasets to the extent of the EU elevation data, we end up losing some of the data from the EU forest dataset, such as the records from Northern Africa and the Canaries. We aggregate the elevation to 100m (from 25m) both for ease of computation and *is there a biological reason??* - also characteristic scale of variation? doesn't really change visually much from 25m to 100m - need to do some kind of test to make sure this simplification if valid. 

We will use the moving window to upscale the variation in elevation at three scales: 500 m, 1 km, 2 km. We do not have *a priori* expectation of the appropriate scale of effect, but we do have reason to expect that variation in elevation will determine species richness due to the opening up of niche space [citations]. We will also calculate variation in elevation at the 0.5 degree scale. As covariates, to avoid confounding variables, we will calculate average temperature and precipitation at the 0.5 degree scale. 

```{r envdata, eval = FALSE}
# This section only gets run the first time (or if changed) and the output saved
# to file. Set eval = FALSE at all other times.

wc_bio <- getData('worldclim', var = "bio", res = 10, path = "../data/worldclim/")
wc_bio_30 <- aggregate(wc_bio, 3)

# load in the elevation data
elev <- raster("../DATA/elev/eudem_dem_3035_europe.tif")

# get forest and climate data in same projection as elev and crop worldclim data by the EU forest dataset
forests <- spTransform(forests, crs(elev))
wc_bio_30 <- projectRaster(wc_bio_30, crs = crs(elev))

# crop climate data
bounds <- extent(elev) 
wc_bio_eu <- crop(wc_bio_30, bounds)

# rasterise the EU forest data to create total species richness (the input function gets the total number of unique species in a cell)
forests_r <- rasterize(forests, wc_bio_eu, fun=function(x, ...){ length(unique(na.omit(x)))})[[2]]

# create a grid for the moving window and elevation aggregation to loop through - I want to move this into the package at some point
eu_grid <- as(forests_r, 'SpatialPolygonsDataFrame')

agg_cell <- function(grid, dat, cell_no, fact, fn="mean", ...) {
  cell <- grid[cell_no,]
  dat_cell <- crop(dat, cell, filename='../temp_raster/temp_crop.tif', overwrite=TRUE)
  dat_cell_agg <- aggregate(dat_cell, fact, fun = fn, filename='../temp_raster/temp_agg.tif', overwrite=TRUE)
  zero_to_na <- function(x) ifelse(x==0, NA, x)
  dat_cell_na <- calc(dat_cell_agg, zero_to_na, ...)
}

elev_cell_100 <- list()

for(cell_no in 1:length(eu_grid)) {
  elev_cell_100[[cell_no]] <- agg_cell(eu_grid, elev, cell_no, 4, filename=paste0('../DATA/temp_raster/temp_agg_', cell_no, '.tif'), overwrite=TRUE)
}

# need to add the arguments to mosaic as attributes of the raster list. 
rasters.mosaicargs <- elev_cell_100
rasters.mosaicargs$fun <- mean
rasters.mosaicargs$filename <- '../DATA/elev/eudem_100m_aggregated.tif'
rasters.mosaicargs$overwrite <- TRUE
elev_100 <- do.call(mosaic, rasters.mosaicargs)

# create the grid level elevation variance
elev_grid <- aggregate(elev_100, res(forests_r)/res(elev_100), fun = var,
                       filename='../DATA/temp_raster/elev_grid.tif', overwrite=TRUE)

# upscale the eu elevation data using the moving window approach
eu_grid$win_var_500 <- winmove_upscale(eu_grid, elev_100, 500, "rectangle", "var", na.rm=TRUE)$V1
eu_grid$win_var_1000 <- winmove_upscale(eu_grid, elev_100, 1000, "rectangle", "var", na.rm=TRUE)$V1
eu_grid$win_var_2000 <- winmove_upscale(eu_grid, elev_100, 2000, "rectangle", "var", na.rm=TRUE)$V1

# stack variables
win_var_500 <- rasterize(eu_grid, forests_r, field = eu_grid@data$win_var_500, fun = "mean")
win_var_1000 <- rasterize(eu_grid, forests_r, field = eu_grid@data$win_var_1000, fun = "mean")
win_var_2000 <- rasterize(eu_grid, forests_r, field = eu_grid@data$win_var_2000, fun = "mean")

var_list <- lapply(list(forests_r, win_var_500, win_var_1000, win_var_2000, elev_grid, wc_bio_eu),
                   function(x) crop(x, elev_grid))
var_stack <- stack(var_list)
names(var_stack)[1:5] <- c("sprich", "winvar500", "winvar1000", "winvar2000", "elevvar")
writeRaster(var_stack, filename="results/forests_covariates.tif", options="INTERLEAVE=BAND", overwrite=TRUE)
forests_df <- as.data.frame(var_stack, xy = TRUE) %>% na.omit
save(forests_df, file="results/forests_covariates.Rda")
```

### Exploration and transformation

What do the variables look like spatially?

```{r spatial_plot, fig.width = 12}
load("results/forests_covariates.Rda")

forests_narrow <- mutate_at(forests_df, .vars = vars(-sprich), .funs = funs(scale)) %>%
  gather(variable, value, -x, -y) %>%
  filter(variable %in% coefforder) %>%
  mutate(variable = factor(variable, levels = coefforder, labels = coefflabels))

sp_plot <- ggplot(forests_df, aes(x = x, y = y, fill = sprich)) + 
  geom_raster() + coord_equal() + 
  scale_fill_viridis_c(name = "Species Richness", option = "magma") + 
  xlab("") + ylab("") + theme(axis.text = element_blank())

cov_plot <- ggplot(forests_narrow, aes(x = x, y = y, fill = value)) + 
  geom_raster() + coord_equal() + 
  facet_wrap(~variable) +
  scale_fill_viridis_c() + 
  xlab("") + ylab("") + theme(axis.text = element_blank())

plot_grid(sp_plot, cov_plot)
```

what are the minimum and maximum values? 

```{r maxmin_data}
select(forests_df, varorder) %>%
  summarise_all(funs(min, max)) %>% 
  gather(variable, value) %>% 
  separate(variable, into = c("variable", "minmax"), sep="_") %>%
  spread(minmax, value) %>% select(variable, min, max) %>%
  mutate(variable = factor(variable, levels = varorder)) %>%
  arrange(variable) %>%
  kable(digits = 3)
```

How are the variables distributed?

```{r distribution}
forests_narrow <- gather(forests_df, variable, value) %>% 
  # order variables by response, interested, covariate
  filter(variable %in% varorder) %>%
  mutate(variable = factor(variable, levels = varorder))

ggplot(forests_narrow, aes(x = value)) + 
  geom_histogram(bins = 30) + 
  facet_wrap(~variable, scales = "free_x")
```

Species richness ideal for Poisson distribution, right skew to MW Elevation and LS elevation, as well as the precipitation variables. 

And where are the correlations?

```{r pairs}
ggpairs(forests_df %>% select(varorder))
```

Not so great. WB Elevation is the lowest correlation except for total precipitation (bio12). Highest correlation is with precipitation seasonality (bio15). 

Note that I chose 2 km because it made sense, but when doing this with other window sizes, the correlation was lower. Perhaps I need to try larger window sizes (and look up a biologically meaningful reason).
```{r transform}
# optimise to find optimal value for log transform
skew.score <- function(c, x) (skewness(log(x + c)))^2
c.winvar2000 <- optimise(skew.score, c(0, 20), x = forests_df$winvar2000)$minimum
c.elevvar <- optimise(skew.score, c(0, 20), x = forests_df$elevvar)$minimum
c.bio12 <- optimise(skew.score, c(0, 20), x = forests_df$bio12)$minimum
c.bio15 <- optimise(skew.score, c(0, 20), x = forests_df$bio15)$minimum


forests_df_t <- select(forests_df, varorder) %>% 
  mutate(winvar2000 = log(winvar2000 + c.winvar2000),
         elevvar = log(elevvar + c.elevvar),
         bio12 = log(bio12 + c.bio12),
         bio15 = log(bio15 + c.bio15))

forests_narrow_t <- gather(forests_df_t, variable, value) %>% 
  mutate(variable = factor(variable, varorder))

ggplot(forests_narrow_t, aes(x = value)) + 
  geom_histogram(bins = 30) + 
  facet_wrap(~variable, scales = "free_x")
```

Better, stick with this for now. It's fine because we don't need to interpret these coefficients. 

Now scale the data (mean = 0, sd = 1) so that the partial regression coefficients are comparable. 

```{r scale_data}
forests_df_t <- mutate_at(forests_df_t, .vars = vars(-sprich), .funs = funs(scale))
```

## Models

### Global model

```{r}
mod_global <- glm(sprich ~ winvar2000 * elevvar * bio1 * bio12 * bio15, family = "poisson", data = forests_df_t, na.action = na.fail)
```

